## 16.07.2020

- В rust-analyzer импорт считается resolved если он стал resolved хотя бы в одном namespace (for performance reason)
- Понял как обрабатываются glob импорты - каждый глоб импорт можем рассматривать как ребро из одного модуля в другой,
  тогда используем обратный граф
- Проблемы с циклическими ссылками. Можем попробовать хранить id как в rust-analyzer, или как строки (crateRelativePath)

Тесты: NameResolution.kt 1289 Service вроде CrateGraphService, нужно зависеть от
PsiModificationTracker.MODIFICATION_COUNT Но лучше от Project.rustStructureModificationTracker

## 17.07.2020

Я:

- Сделал чтобы можно было использовать наш crateDefMap (полезно для тестов)
- Написал часть кода fixed point Идеи:
- В CrateDefMap хранить Map<FileId, FileHash>, вместо rustModificationTracker при изменениях файла пересчитывать его
  хеш (с точки зрения резолва), и пересчитывать map только если хеш изменился
- По CrateDefMap можем построить семантический индекс, то есть индекс с учётом резолва (в отличие от синтаксического
  индекса)
  Например индекс реекспортов - хотим для каждого айтема (структура/функция/...) находить модули которые реэкспортируют
  этот айтем Видимо просто смотрим на каждый импорт, понимаем какие элементы он импортирует (с помощью CrateDefMap), и
  заполняем обратную map'у
- Проблема: хотим работать с некорректным кодом, в частности multiresolve - когда в одном модуле доступны несколько
  айтемов с одним именем в одном неймспейсе Простой случай: в одном модуле объявлено несколько функций с одним именем -
  всё ок, решаем в самом конце когда возвращаемся к Psi Иначе непонятно, в PerNs не хочется хранить списки, так как
  будет медленно

## 18.07.2020

- Legacy macros - которые резолвятся в порядке появления, а не как обычные items
- Glob-импорты импортируют unnamed traits. Можно добавить в ModData `unnamedTraits: List<VisItem>`
- Time travel. По идее запрещён, но: https://github.com/rust-lang/rust/issues/74556

## 27.07.2020

- cfg-disabled: решили забить и сделать попроще - добавить новую visibility, которая ещё менее приоритетнее чем
  unresolved
- макросы:
    - # [macro_export] макрос автоматически попадает в crate root и может быть доступен из любого модуля через `crate::name`
    - # [macro_use] на mod declaration - добавляет legacy макросы в текущий scope
    - `pub use _name as name;` - "переводим legacy макрос в обычный"
- макросы:
    - `include!(filepath)`, для начала можно даже без проверки что `include` это макрос из std
    - обычные (не legacy) макросы, должны почти автоматически заработать
    - legacy макросы
        - можно подумать над какими-нибудь структурами данных (напр. по особенному индексировать элементы в модуле, с
          учётом раскрытия макросов)
        - можно сделать как в rust-analyzer (не всегда правильно работает)
            - идём по дереву модулей
            - встретили macro_rules - добавляем в словарь
            - встретили macro call - достаём из словаря
            - такой one-way проход, раньше так было реализовано в rustc

## 04.08.2020

### Контекст при раскрытии макросов

Проблема: раскрываем макрос, можем получить mod-объявление, нужно установить родительский модуль (RsMod) как контекст
Идея 1:
Полностью отказаться от резолва модулей на PSI - добавить всю нужную информацию в ModData (fileId, virtualFile,
pathAttribute)
Соответственно если это мод объявление то честно сами резолвим файл по имеющейся информации, без PSI в идеале
переиспользовать существующий код резолва - processModDeclResolveVariants и getOwningDirectory Идея 2:
Когда мы collect macroCall - у нас же уже есть родительский модуль (RsMod), давайте прокинем его как контекст Видимо
работает только для inline модулей верхнего уровня

### Убрать ленивость

MacroExpansionTask - вызывается при открытии проекта, после cargo refresh и при изменении макросов
(Изменение макросов трекается очень хитро, с помощью магии на stub'ах, лучше так никогда не делать)
Добавляем в начало этой MacroExpansionTask:

```
topSortedCrates.forEach { it.defMap = buildDefMap(it) }
incRustStructureModificationCount()  // нужно ли ещё платформенный tracker сбрасывать? нет, если он нигде не используется
DaemonCodeAnalyzer.getInstance(project).restart()  // чтобы точно highlighting перезапустился
```

### Индекс для поиска родительских модулей

Индексируем файл, в нём есть mod-объявление, по абсолютному пути к текущему файлу и возможному path-атрибуту на
mod-объявление находим абсолютный путь к дочернему модулю, кладём в индекс childAbsolutePath -> parentFileId
Проблема: `include!` макрос

## 05.08.2020

Пока не готов DefMap нельзя делать рефакторинги ? Да, но можно для начала забить

local_inner_macros - хотели добавлять $crate ко всем macro call непонятно когда это делать

- после раскрытия - как найти macro calls? у нас нет PSI, только текст раскрытия
- после парсинга - возможно проблемы с write action ?

## 06.08.2020

Идея: распараллелить построение CrateDefMap (учитывая зависимости)

## 07.08.2020

- Доделал $crate, всё работает
- Исправил забавный баг, когда из макроса раскрывается мод-объявление у которого есть path-атрибут
- Сделал параллельное построение DefMap
    - Сначала на CompletableFuture - кажется плохо работало
    - Потом как мы обсуждали - почему-то по времени не улучшилось намного
    - Как лучше обрабатывать ошибки

## 10.08.2020

- Потестировал на mysql_async, исправил два бага, уже забыл какие
- Добавил name в RsResolveProcessor - можно сделать PR?
- Профилировал, получилось что
    * processItemDeclarations в master занимает примерно 30% от всего резолва
    * processItemDeclarations с новым резолвом стало примерно 10%, то есть общее время резолва уменьшилось примерно на
      10-20%
    * Треть от processItemDeclarations занимает получение ModData по RsMod
        - можно положить в DefMap мапку из fileId в ModData

## Митинг неделя 03-07

- $crate
- Поддержка cfg-disabled элементов
- Построение всех CrateDefMap перед macro expansion
- Параллельное построение CrateDefMap
- Оптимизировал resolve, чтобы просматривались не все элементы в scope модуля, а только с нужным именем
    - Теперь новый резолв (после разрешения всех импортов) стал работать немного быстрее чем текущий резолв

## 13.08.2020

- Custom resolve for RsModDeclItem
    - Нашёл небольшой баг в реализации getOwningDirectory
- Optimize finding ModData by RsMod
- Попробовал запустить все тесты (а не только резолва), некоторые падают, разбираюсь

## 14.08.2020

- Сделал чтобы если при параллельном построении DefMap возникла exception, то она прокидывалась выше
    - Вопрос: Если defMap ещё не готова, мы возвращаем null
- Протестировал на проектах кроме cargo и mysql
    - Нашёл и исправил ошибку с $crate связанную с inline модулями
    - Large files
    - нашёл ошибку с RangeMap

Что делать если defMap ещё не готова?

- Нельзя ждать пока она будет готова, потому что например рефакторинги выполняются в write action, будет deadlock
- Если мы сейчас находимся в write action, можно лениво её считать - то есть считать её прямо в write action когда хотим
  её получить
- С макросами должна возникать такая же проблема? кажется макросы не сильно поддреживаются в рефакторингах, поэтому это
  не заметно?
- Решили пока забить

## 15.08.2020

Вопросы:

- Autoreparse интервал не работает? По крайней мере не влияет на частоту вызовов rustPsiChanged
    - A: Не очень критично - пока можно забить
- PsiFile.modificationStamp vs VirtualFile.modificationStamp vs VirtualFile.timeStamp
    - Только PsiFile.modificationStamp гарантированно обновляется (остальные только когда файл будет сохранён на диск)
    - Только VirtualFile.timeStamp сохраняется после рестарта IDE
    - **A: Нужно использовать viewProvider.modificationStamp**
- Поменялся порядок legacy макросов с одним именем - не поддерживается ?
    - A: Нужно сортировать только если порядок не важен. Для начала можно вообще не сортировать
- ModCollector в любом случае нужно переиспользовать, потому что иначе придётся при buildDefMap дважды делать collect ?
- Порядок импортов - сначала считаем hashCode, затем сортируем по hashCode, затем делаем digest.update(). Ок?
    - **A: Не надо использовать hashCode, лучше полностью сериализовать в MessageDigest - DigestOutputStream + nullable
      OutputStream**

## Митинг неделя 10-14

- В новом резолве на этапе разрешения всех импортов нельзя использовать резолв (иначе рекурсия).
    - Из-за этого возникали проблемы при резолв mod-деклараций, поэтому я его изменил чтобы работал без PSI При этом
      нашёл багу при резолве mod-деклараций внутри inline-модулей с path атрибутом - мб кто-нибудь посмотрит PR
    - Плюс аналогичная проблема с рекурсией при проверке что item является cfg-enabled, тоже исправил
- Исправил обработку $crate для макросов раскрывающихся в inline модуль
- Мы с Владом обсудили инкрементальный запуск нового резолва, то есть как запускать алгоритм разрешения импортов только
  если это нужно, а не на любое изменение файла
    - В качестве первого шага сделал чтобы при изменении файла пересчитывался резолв только для текущего крейта

## 19.08.2020

- `file.viewProvider.modificationStamp` - не монотонный после рестарта IDE ?
- Тесты на изменение кода
- Проблемы c hash для crate root:
    - `extern crate std;` injection
    - `#[macro_export]` - добавляет VisItem в crate root

### Modification stamp

- Во время работы IDE используем FileViewProvider.getModificationStamp
- На диск сохраняем VirtualFile.getModificationCount
- При первом создание сервиса сравниваем VirtualFile.getModificationCount, если совпадают, то используем текущий
  FileViewProvider.getModificationStamp в качестве начального значения
- Слушаем сохранения файлов (FileDocumentManagerListener.beforeDocumentSaving), сравниваем
  FileViewProvider.getModificationStamp - если не изменился, то обновляем VirtualFile.getModificationCount в нашей
  структуре. Also: FileDocumentManager.getInstance().isDocumentUnsaved(file?.document)

### Тесты изменяющие файлы

RsMacroExpansionCachingTest RsMacroExpansionCachingToolchainTest
org.rust.lang.core.types.infer.RsInferenceResult#getTimestamp RsTypeInferenceCachingTest
org.rust.lang.core.macros.VfsInternals#getContentHashIfStored

## 24.08.2020

Доделал подсчёт хеша напрямую, без использования ModData

## Неделя 17-21

- Мы с Артёмом замёрджили два PR про move refactoring
    - при перемещении элементов новый путь теперь ищется с учётом реекспортов
    - при перемещении структуры или трайта в диалоге по умолчанию будут выбраны все связанные impl блоки
- Влад сделал кеш раскрытий макросов и я добавил его в новый резолв, и теперь этап когда заполняются скоупы всех модулей
  стал в три раза быстрее, на проекте Cargo занимает примерно 2-3 секунды
- Работал над инкрементальностью в новом резолве. Идея в том, что если мы что-то изменяем внутри функции, или например
  меняем местами две функции, то на резолв это никак не влияет и заново разрешать все импорты не надо. И вот я сделал
  чтобы когда мы разрешаем все импорты, для каждого файла считался его хеш с точки зрения резолва, и когда потом файл
  изменяется, мы снова считаем хеш файла и сравниваем его с сохранённым хешом, и если хеши равны то можем не разрешать
  заново все импорты.

## 25.08.2020

- Don't expand cfg-disabled macro calls

## 25.08.2020

- Don't expand cfg-disabled macro calls (доделал)
- Тесты на инкрементальность при изменении одного файла

## 31.08.2020

- Нужно удалять std из dependencies если есть `!#[no_std]` ?
  https://github.com/intellij-rust/intellij-rust/pull/5474

## Неделя 24-28

- New resolve:
    - На прошлой неделе я начал делать инкрементальный запуск алгоритма разрешения всех импортов, и добавил обработку
      изменения файлов. На этой неделе я добавил обработку создания файлов, это нужно например если есть unresolved
      mod-декларация
    - Также теперь после cargo sync для всех крейтов проверяется не нужно ли заново разрешить все импорты, при этом
      сравнивается метаданные крейтов (например cargo features), и modification stamps всех файлов
    - Немного поотимизировал алгоритм разрешени всех импортов, в частности обработки cfg-disabled элементов
- Мы с Владом замёрджили PR отключающий раскрытие cfg-disabled макросов, это примерно на треть ускоряет первичное
  раскрытие макросов в проекте Cargo
- Мы с Артёмом замёрджили PR про move refactoring, который добавляет проверку конфликтов видимости при перемещении
  элементов
- Открыл два pull request про move refactoring:
    - перемещаемые элементы делаются публичными если нужно, т.е. например если они использовались в старом родительском
      модуле
    - в диалоге выбора элементов для перемещения теперь структуры и трейты сгруппированы вместе со связанными impl
      блоками

## Неделя 31-04

- Исправил несколько небольших багов в новом резолве:
    - # [no_std]
    - `extern crate`:
        - visibility
        - with underscore alias
        - `extern crate self`
- Немного пооптимизировал новый резолв - ту часть когда разрешаются все импорты
- Исправил работу нового резолва при вызове из рефакторингов. Типичный рефакторинг: что-то меняет внутри write action, и
  потом вызывает резолв

## Неделя 31-04

- Исправил несколько небольших багов в новом резолве:
    - # [no_std]
    - extern crate:
        - visibility
        - with underscore alias
        - extern crate self
- Немного пооптимизировал новый резолв - ту часть когда разрешаются все импорты
- Исправил работу нового резолва при вызове из рефакторингов. Типичный рефакторинг: что-то меняет внутри write action, и
  потом вызывает резолв

## 07.09.2020

+ ImportHelper создаёт tmp модули - сделал чтобы использовался существующий резолв для таких модулей
+ Файлы без crate root - тоже сделал чтобы использовался текущий резолв
    - Например в некоторых тестах используется файл aaa.rs

- Бывает что мы хотим resolve без приватных айтемов (например в completion)
  Как это учесть в новом резолве? Мб добавить модуль в котором происходит completion в ResolveProcessor?
- is ChildrenChange.After -> if (!event.isGenericChange) event.parent else return // почему else return? Если после
  VfsUtil.saveText modification tracker не меняется, то это похоже баг, надо отправить Владу
  *Нужен новый modification tracker учитывающий макросы*

+ tryReadAction ?

### Try read action

У макросов есть два индикатора:

- глобальный, отменяется когда запускается другая MacroExpansionTask
- локальный, отменяется когда запускается write action Внутри macro expansion task: проверяем оба индикатора, если
  локальный отменился, то ждём завершения write action и повторяем действие Из резолва - используем tryReadAction

Из резолва - может стоит сделать чтобы не ждать если понимаем что будет выполняться долго? Например часть подсветки
можно сделать без резолва

### Private visibility

visibility: private import vs private item можно в visibility inspection резолвить и проверять не RsItem, а VisItem
ResolveResult - обычно содержит BoundResult - можно добавить VisItem RsPathReference Добавить visibility в ScopeEntry,
потом перекладываем в BoundElement В completion - filterCompletionVariantsByVisibility - там есть ScopeEntry, проверяем
её visibility?

В completion приватные айтемы не показываются - Влад говорит что это ок, в kotlin также работает?

## 10.09.2020

- Proc macros? (нужно ли их поддерживать и т.д.)
- В tokio есть циклическая зависимость tokio ->dev tokio-test -> tokio Нельзя сделать отдельный крейт для tokio(test) ?
  **Пока отложим**

## Неделя 07-11

* Открыл PR для move refactoring добавляющий поддержку перемещения нескольких файлов
* Запустил regression тесты для нового резолва и нашёл много регрессий:
    * 63 для cargo
    * 1176 для tokio
    * 206 для amethyst
* Исправлял различные баги в новом резолве
    * Поддержал мультирезолв в случае когда элементы с одним именем находятся в одном файле
    * cargo - 0
    * tokio - 170 / 2000
    * amethyst - 11 / 500

## 28.09.2020

Измерил память через System.gc():

- Cargo:    ~200MB
- Amethyst: ~900MB Измерил память через heap dump:
- Cargo:    ~100MB
- Amethyst: ~400MB
- rustc:     310MB

## Неделя 21-25

Причёсывал код

## 30.09.2020

* Performance THashMap - примерно на 20% хуже, в частности из-за того что нет эффективных реализация putIfAbsent
* Проблема с кешированием expandedItems - если вызывать его во время раскрытия макросов, то закешируется неправильное
  значение, а в конце macro expansion task structureModificationTracker не увеличится
* Остальные регрессии
    * clap - все регрессии из-за cfg(feature) и cfg(not(feature))
    * juniper - proc macros, CustomResult vs Result
    * amethyst - вроде все связаны с alias
* Symlink

## 05.10.2020

* Правда что раскрываются только top level macros?
  *A*: Да
* Резолв макросов внутри expansion task без PSI
    - macro call начинающийся с $crate ?
      *A*: Обрабатываем также как сейчас (аккуратно ищем macro def, включая local_inner_macros)
    - macro call внутри expanded модуль?
      *A*: Поднимаемся по context пока не найдём не expanded модуль
    - мб сделать без кеша?
      *A*: Вроде есть пример когда не работает даже если отключить кеш?

## Неделя 28-02

* На прошлой неделе я говорил что новый резолв на крейте amethyst занимает 400МБ памяти; ..., 300; THashMap, 200
* Обнаружилась интересная бага - в новом резолве когда резолвится макрос, используется метод expandedItems который
  возвращает все элементы модуля (включая раскрытые из макросов)
  Внутри этого метода раскрываются все macro calls, для этого их нужно зарезолвить. Получается такая рекурсия и в итоге
  так как этот метод expandedItems кеширует результат, то кешируется неправильное значение. Влад предложил изменить
  резолв макросов внутри expansion task чтобы он работал без psi и возвращал какой-нибудь data class Я так сделал и это
  решило исходную проблему но создало новые, разбираюсь
* Исправил небольшой баг в intention для создания функции - если функция создаётся в другом крейте, то нужно
  использовать `pub` а не `pub(crate)` видимость

## 06.10.2020

- Может ли processItemsDeclarations быть вызван на expanded модуле?
  *A:* У нас это и так работает (мы используем containingMod + super)
- Работает ли в тестах резолв внутрь macro_rules ?
  *A:* Нет, только внутрь macro call (в тело macro call)
  Подробнее: MacroExpansionResolveTest, MacroResolveTest, MacroCallReferenceDelegationTest,
  MacroExpansionRangeMappingTest

## Неделя 05-09
* REPL - поддержал команду clear при которой должно очищаться variables view
* Для пустого match показываются две intention - добавить все паттерны и добавить wildcard паттерн, 
  обсудили с Артёмом, что нет смысла добавлять wildcard для пустого match, и я убрал эту intention 
* В новом резолве добавил modification tracker учитывающий изменения в макросах (можно определить как сумму текущего и ещё одного нового, для макросов)
* Открыл PR с новым резолвом

## 12.10.2020
* Хочет ли Влад чтобы я добавил тесты?
  *A:* Not a big deal

## 13.10.2020
* Можно ли удалить код для #[macro_reexport], который был удалён в 2018? https://github.com/rust-lang/rust/pull/49982
  *A:* Да
* derive proc macro - мультирезолв для serde в trait
  *A:* Текущая реализация очень плоха, пока забиваем. 
  Самое грустное что часть кода резолва полагается на то что резолв для derive возвращает trait
* processMultiResolveWithNs
  Надо выпилить. (не очень понял, возможно Влад сам выпилит)

## 14.10.2020
- Как находятся impl? *A:* По индексу

Review notes: 
* заменить read action на неблокирующие
* macro task try catch
* onfileadded, onfileremoved - проверить rename
* fileIdsToCrateId - очищать в removeStaleDefMaps
* одна функция в defmapservice - заменить defmap с oldValue на newValue
* плюс вся мутабельность приватная в defmapservice
* shouldRebuild, shouldRecheck - comments
* заменить какие-то pair на data class
* testAssert {false} - выпилить
* hash file - чтобы не зависел от isdeeplyenabled (а macro calls например игнорировать в collector а не в collectorbase) (но мб и не нужно - подумать)
* добавить коммент к hashcalculator - что он считает для всех inline модулей конкретного файла
* идея для теста - менять что-нибудь рандомное а затем force rebuild defmap и сравнивать нужно ли было перестраивать
* visibility === visibilityNew - заменить на ==
* === - нужен?
* setContext - обновить коммент (теперь там стабы)
* defMapHolder - либо убрать volatile либо добавить коммент (смотри SourceFile)
* todo: macro def раскрывается из macro def - propagate в дочерние модули (добавить в todo)
* переименовать samethreadexecutor
* hashCalculator - в конструктор

## 19.10.2020
- много мутабельности, хотим потребовать все изменения под одним lock filterAsync - нужен если много крейтов проверяем
  снаружи filterAsync есть lock, внутри нету
  *A:* страдать
- shouldRecheckAllCrates - atomic - ок?
  *A:* вроде не нужно, там же есть write lock,
- Что с std в rustc?
  *A:* нужно для std из workspace сделать origin=stdlib и в других крейтах заменить std зависимость на из workspace
  сейчас (?) вроде std из workspace игнорируется, а в std из toolchain заменяется path на workspace
- Resolve proc macro derive - правда что не обязательно трайт имеет такой же путь?
  *A:* у нас сейчас вообще резолв proc macros по имени (по индексу), а не по пути

## Неделя 12-16
Новый резолв:
- Добавил резолв процедурных макросов кроме derive - исправил небольшой баг - если есть cfg-disabled модуль и
односегментный импорт с таким же именем, то импорт должен перекрывать модуль - исправил резолв внутри cfg-disabled
модулей - Влад поревьюл PR про новый резолв и я исправлял комментарии (и всё ещё исправляю)
- Доделал чтобы в таске раскрытия макросов резолв макросов был без PSI

## 09.11.2020
* fileIdToCrateId - хотим использовать в RsFile.containingCrate
  Проблема: что если CrateDefMap ещё не посчиталась, и следовательно fileIdToCrateId ещё не обновилась?
  Всегда обновлять все DefMap не хочется наверно?
  Старый способ (через mod decl) тоже очень не хочется использовать в таких случаях (хотя такие случаи должны быть очень редкими)
* fileIdToCrateId - вообще файл может лежать в нескольких крейтах...
* Глобальная проблема: внутри функций используется старый резолв, поэтому приходится поддерживать старый резолв, чего очень не хочется
  Как можно использовать новый резолв внутри функций?
  Например считать что каждая функция это отдельная ModData/CrateDefMap и создавать их на лету?
  Что делать с вложенными скоупами в функциях?

## 18.11.2020
* Хранить рядом со стабами наши дата классы
  com.intellij.util.indexing.IndexExtension
  com.intellij.util.indexing.SingleEntryFileBasedIndexExtension
  com.intellij.util.indexing.SingleEntryIndexer.computeValue
  computeValue - StubTreeBuilder.build - стабы построятся один раз
* Добавить новый кеш рядом с кешом макросов, напрямую из combined hash в наши дата классы

## 24.11.2020
* `RsUseItem.delete()` - structureTracker не увеличивается
* Почему в completion нету приватных элементов (хотя бы в конце списка)? 
* Недостаточно ScopeEntryWithVisibility, всё равно нужно вместе с процессором передавать sourceMod?
* seed - macro expanded to macro
